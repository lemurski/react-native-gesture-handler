//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (all) => {
	let target = {};
	for (var name$2 in all) __defProp(target, name$2, {
		get: all[name$2],
		enumerable: true
	});
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let __eslint_react_shared = require("@eslint-react/shared");
__eslint_react_shared = __toESM(__eslint_react_shared);
let __eslint_react_ast = require("@eslint-react/ast");
__eslint_react_ast = __toESM(__eslint_react_ast);
let __eslint_react_core = require("@eslint-react/core");
__eslint_react_core = __toESM(__eslint_react_core);
let __eslint_react_kit = require("@eslint-react/kit");
__eslint_react_kit = __toESM(__eslint_react_kit);
let __typescript_eslint_utils = require("@typescript-eslint/utils");
__typescript_eslint_utils = __toESM(__typescript_eslint_utils);
let __eslint_react_eff = require("@eslint-react/eff");
__eslint_react_eff = __toESM(__eslint_react_eff);
let __typescript_eslint_types = require("@typescript-eslint/types");
__typescript_eslint_types = __toESM(__typescript_eslint_types);
let ts_pattern = require("ts-pattern");
ts_pattern = __toESM(ts_pattern);
let node_path = require("node:path");
node_path = __toESM(node_path);
let string_ts = require("string-ts");
string_ts = __toESM(string_ts);

//#region src/configs/recommended.ts
var recommended_exports = __export({
	name: () => name$1,
	rules: () => rules
});
const name$1 = "react-naming-convention/recommended";
const rules = { "react-naming-convention/context-name": "warn" };

//#endregion
//#region package.json
var name = "eslint-plugin-react-naming-convention";
var version = "1.53.1";

//#endregion
//#region src/utils/create-rule.ts
const createRule = __typescript_eslint_utils.ESLintUtils.RuleCreator((0, __eslint_react_shared.getDocsUrl)("naming-convention"));

//#endregion
//#region src/rules/component-name.ts
const defaultOptions$2 = [{
	allowAllCaps: false,
	excepts: [],
	rule: "PascalCase"
}];
const schema$2 = [{ anyOf: [{
	type: "string",
	enum: ["PascalCase", "CONSTANT_CASE"]
}, {
	type: "object",
	additionalProperties: false,
	properties: {
		allowAllCaps: { type: "boolean" },
		excepts: {
			type: "array",
			items: {
				type: "string",
				format: "regex"
			}
		},
		rule: {
			type: "string",
			enum: ["PascalCase", "CONSTANT_CASE"]
		}
	}
}] }];
const RULE_NAME$4 = "component-name";
var component_name_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions$2],
		docs: { description: "Enforces naming conventions for components." },
		messages: { invalidComponentName: "A component name '{{name}}' does not match {{rule}}." },
		schema: schema$2
	},
	name: RULE_NAME$4,
	create: create$4,
	defaultOptions: defaultOptions$2
});
function create$4(context) {
	const options = normalizeOptions(context.options);
	const { rule } = options;
	const collector = __eslint_react_core.useComponentCollector(context);
	const collectorLegacy = __eslint_react_core.useComponentCollectorLegacy();
	return {
		...collector.listeners,
		...collectorLegacy.listeners,
		"Program:exit"(program) {
			const functionComponents = collector.ctx.getAllComponents(program);
			const classComponents = collectorLegacy.ctx.getAllComponents(program);
			for (const { node: component } of functionComponents.values()) {
				const id = __eslint_react_ast.getFunctionId(component);
				if (id?.name == null) continue;
				const name$2 = id.name;
				if (isValidName(name$2, options)) continue;
				context.report({
					messageId: "invalidComponentName",
					node: id,
					data: {
						name: name$2,
						rule
					}
				});
			}
			for (const { node: component } of classComponents.values()) {
				const id = __eslint_react_ast.getClassId(component);
				if (id?.name == null) continue;
				const name$2 = id.name;
				if (isValidName(name$2, options)) continue;
				context.report({
					messageId: "invalidComponentName",
					node: id,
					data: {
						name: name$2,
						rule
					}
				});
			}
		}
	};
}
function normalizeOptions(options) {
	const opts = options[0];
	const defaultOpts = defaultOptions$2[0];
	if (opts == null) return defaultOpts;
	return {
		...defaultOpts,
		...typeof opts === "string" ? { rule: opts } : {
			...opts,
			excepts: opts.excepts?.map((s) => __eslint_react_kit.RegExp.toRegExp(s)) ?? []
		}
	};
}
function isValidName(name$2, options) {
	if (name$2 == null) return true;
	if (options.excepts.some((regex) => regex.test(name$2))) return true;
	const normalized = name$2.split(".").at(-1) ?? name$2;
	switch (options.rule) {
		case "CONSTANT_CASE": return __eslint_react_kit.RegExp.CONSTANT_CASE.test(normalized);
		case "PascalCase":
			if (normalized.length > 3 && /^[A-Z]+$/u.test(normalized)) return options.allowAllCaps;
			return __eslint_react_kit.RegExp.PASCAL_CASE.test(normalized);
	}
}

//#endregion
//#region src/rules/context-name.ts
const RULE_NAME$3 = "context-name";
var context_name_default = createRule({
	meta: {
		type: "problem",
		docs: { description: "Enforces context name to be a valid component name with the suffix `Context`." },
		messages: { invalidContextName: "A context name must be a valid component name with the suffix 'Context'." },
		schema: []
	},
	name: RULE_NAME$3,
	create: create$3,
	defaultOptions: []
});
function create$3(context) {
	if (!context.sourceCode.text.includes("createContext")) return {};
	return { CallExpression(node) {
		if (!__eslint_react_core.isCreateContextCall(context, node)) return;
		const id = __eslint_react_core.getInstanceId(node);
		if (id == null) return;
		const name$2 = (0, ts_pattern.match)(id).with({
			type: __typescript_eslint_types.AST_NODE_TYPES.Identifier,
			name: ts_pattern.P.select()
		}, __eslint_react_eff.identity).with({
			type: __typescript_eslint_types.AST_NODE_TYPES.MemberExpression,
			property: { name: ts_pattern.P.select(ts_pattern.P.string) }
		}, __eslint_react_eff.identity).otherwise(() => null);
		if (name$2 != null && __eslint_react_core.isComponentName(name$2) && name$2.endsWith("Context")) return;
		context.report({
			messageId: "invalidContextName",
			node: id
		});
	} };
}

//#endregion
//#region src/rules/filename.ts
const RULE_NAME$2 = "filename";
const defaultOptions$1 = [{
	excepts: [
		"index",
		String.raw`/^_/`,
		String.raw`/^\$/`,
		String.raw`/^[0-9]+$/`,
		String.raw`/^\[[^\]]+\]$/`
	],
	rule: "PascalCase"
}];
const schema$1 = [{ anyOf: [{
	type: "string",
	enum: [
		"PascalCase",
		"camelCase",
		"kebab-case",
		"snake_case"
	]
}, {
	type: "object",
	additionalProperties: false,
	properties: {
		excepts: {
			type: "array",
			items: {
				type: "string",
				format: "regex"
			}
		},
		extensions: {
			type: "array",
			items: { type: "string" },
			uniqueItems: true
		},
		rule: {
			type: "string",
			enum: [
				"PascalCase",
				"camelCase",
				"kebab-case",
				"snake_case"
			]
		}
	}
}] }];
var filename_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions$1],
		docs: { description: "Enforces consistent file naming conventions." },
		messages: {
			empty: "A file must have non-empty name.",
			invalidCase: "A file with name '{{name}}' does not match {{rule}}. Rename it to '{{suggestion}}'."
		},
		schema: schema$1
	},
	name: RULE_NAME$2,
	create: create$2,
	defaultOptions: defaultOptions$1
});
function create$2(context) {
	const options = context.options[0] ?? defaultOptions$1[0];
	const rule = typeof options === "string" ? options : options.rule ?? "PascalCase";
	const excepts = typeof options === "string" ? [] : (options.excepts ?? []).map((s) => __eslint_react_kit.RegExp.toRegExp(s));
	function validate(name$2, casing = rule, ignores = excepts) {
		if (ignores.some((pattern) => pattern.test(name$2))) return true;
		const filteredName = name$2.match(/[\w.-]/gu)?.join("") ?? "";
		if (filteredName.length === 0) return true;
		return (0, ts_pattern.match)(casing).with("PascalCase", () => __eslint_react_kit.RegExp.PASCAL_CASE.test(filteredName)).with("camelCase", () => __eslint_react_kit.RegExp.CAMEL_CASE.test(filteredName)).with("kebab-case", () => __eslint_react_kit.RegExp.KEBAB_CASE.test(filteredName)).with("snake_case", () => __eslint_react_kit.RegExp.SNAKE_CASE.test(filteredName)).exhaustive();
	}
	function getSuggestion(name$2, casing = rule) {
		return (0, ts_pattern.match)(casing).with("PascalCase", () => (0, string_ts.pascalCase)(name$2)).with("camelCase", () => (0, string_ts.camelCase)(name$2)).with("kebab-case", () => (0, string_ts.kebabCase)(name$2)).with("snake_case", () => (0, string_ts.snakeCase)(name$2)).exhaustive();
	}
	return { Program(node) {
		const [basename = "", ...rest] = node_path.default.basename(context.filename).split(".");
		if (basename.length === 0) {
			context.report({
				messageId: "empty",
				node
			});
			return;
		}
		if (validate(basename)) return;
		context.report({
			messageId: "invalidCase",
			node,
			data: {
				name: context.filename,
				rule,
				suggestion: [getSuggestion(basename), ...rest].join(".")
			}
		});
	} };
}

//#endregion
//#region src/rules/filename-extension.ts
const RULE_NAME$1 = "filename-extension";
const defaultOptions = [{
	allow: "as-needed",
	extensions: [".jsx", ".tsx"],
	ignoreFilesWithoutCode: false
}];
const schema = [{ anyOf: [{
	type: "string",
	enum: ["always", "as-needed"]
}, {
	type: "object",
	additionalProperties: false,
	properties: {
		allow: {
			type: "string",
			enum: ["always", "as-needed"]
		},
		extensions: {
			type: "array",
			items: { type: "string" },
			uniqueItems: true
		},
		ignoreFilesWithoutCode: { type: "boolean" }
	}
}] }];
var filename_extension_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions],
		docs: { description: "Enforces consistent file naming conventions." },
		messages: {
			missingJSXExtension: "Use {{extensions}} file extension for JSX files.",
			unnecessaryJSXExtension: "Do not use {{extensions}} file extension for files without JSX."
		},
		schema
	},
	name: RULE_NAME$1,
	create: create$1,
	defaultOptions
});
function create$1(context) {
	const options = context.options[0] ?? defaultOptions[0];
	const allow = (0, __eslint_react_eff.isObject)(options) ? options.allow : options;
	const extensions = (0, __eslint_react_eff.isObject)(options) && "extensions" in options ? options.extensions : defaultOptions[0].extensions;
	const extensionsString = extensions.map((ext) => `'${ext}'`).join(", ");
	const filename = context.filename;
	let hasJSXNode = false;
	return {
		JSXElement() {
			hasJSXNode = true;
		},
		JSXFragment() {
			hasJSXNode = true;
		},
		"Program:exit"(program) {
			const fileNameExt = filename.slice(filename.lastIndexOf("."));
			const isJSXExt = extensions.includes(fileNameExt);
			if (hasJSXNode && !isJSXExt) {
				context.report({
					messageId: "missingJSXExtension",
					node: program,
					data: { extensions: extensionsString }
				});
				return;
			}
			const hasCode = program.body.length > 0;
			const ignoreFilesWithoutCode = (0, __eslint_react_eff.isObject)(options) && options.ignoreFilesWithoutCode === true;
			if (!hasCode && ignoreFilesWithoutCode) return;
			if (!hasJSXNode && isJSXExt && allow === "as-needed") context.report({
				messageId: "unnecessaryJSXExtension",
				node: program,
				data: { extensions: extensionsString }
			});
		}
	};
}

//#endregion
//#region src/rules/use-state.ts
const RULE_NAME = "use-state";
const RULE_FEATURES = [];
var use_state_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces destructuring and symmetric naming of `useState` hook value and setter.",
			[Symbol.for("rule_features")]: RULE_FEATURES
		},
		messages: {
			invalidAssignment: "useState should be destructured into a value and setter pair, e.g., const [state, setState] = useState(...).",
			invalidSetterName: "The setter should be named 'set' followed by the capitalized state variable name, e.g., 'setState' for 'state'."
		},
		schema: []
	},
	name: RULE_NAME,
	create,
	defaultOptions: []
});
function create(context) {
	const alias = (0, __eslint_react_shared.getSettingsFromContext)(context).additionalHooks.useState ?? [];
	const isUseStateCall = __eslint_react_core.isReactHookCallWithNameAlias(context, "useState", alias);
	return { CallExpression(node) {
		if (!isUseStateCall(node)) return;
		if (node.parent.type !== __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator) {
			context.report({
				messageId: "invalidAssignment",
				node
			});
			return;
		}
		const id = __eslint_react_core.getInstanceId(node);
		if (id?.type !== __typescript_eslint_types.AST_NODE_TYPES.ArrayPattern) {
			context.report({
				messageId: "invalidAssignment",
				node: id ?? node
			});
			return;
		}
		const [value, setter] = id.elements;
		if (value == null || setter == null) {
			context.report({
				messageId: "invalidAssignment",
				node: id
			});
			return;
		}
		const setterName = (0, ts_pattern.match)(setter).with({ type: __typescript_eslint_types.AST_NODE_TYPES.Identifier }, (id$1) => id$1.name).otherwise(() => null);
		if (setterName == null || !setterName.startsWith("set")) {
			context.report({
				messageId: "invalidSetterName",
				node: setter
			});
			return;
		}
		const valueName = (0, ts_pattern.match)(value).with({ type: __typescript_eslint_types.AST_NODE_TYPES.Identifier }, ({ name: name$2 }) => (0, string_ts.snakeCase)(name$2)).with({ type: __typescript_eslint_types.AST_NODE_TYPES.ObjectPattern }, ({ properties }) => {
			return properties.reduce((acc, prop) => {
				if (prop.type === __typescript_eslint_types.AST_NODE_TYPES.Property && prop.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return [...acc, prop.key.name];
				return acc;
			}, []).join("_");
		}).otherwise(() => null);
		if (valueName == null) {
			context.report({
				messageId: "invalidSetterName",
				node: value
			});
			return;
		}
		if ((0, string_ts.snakeCase)(setterName) !== `set_${valueName}`) {
			context.report({
				messageId: "invalidSetterName",
				node: setter
			});
			return;
		}
	} };
}

//#endregion
//#region src/plugin.ts
const plugin = {
	meta: {
		name,
		version
	},
	rules: {
		["component-name"]: component_name_default,
		["context-name"]: context_name_default,
		["filename"]: filename_default,
		["filename-extension"]: filename_extension_default,
		["use-state"]: use_state_default
	}
};

//#endregion
//#region src/index.ts
const { toFlatConfig, toLegacyConfig } = (0, __eslint_react_shared.getConfigAdapters)("react-naming-convention", plugin);
var src_default = {
	...plugin,
	configs: {
		["recommended"]: toFlatConfig(recommended_exports),
		["recommended-legacy"]: toLegacyConfig(recommended_exports)
	}
};

//#endregion
module.exports = src_default;