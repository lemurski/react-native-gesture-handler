import { DEFAULT_ESLINT_REACT_SETTINGS, getConfigAdapters, getDocsUrl } from "@eslint-react/shared";
import * as AST from "@eslint-react/ast";
import * as ER from "@eslint-react/core";
import { or, unit } from "@eslint-react/eff";
import * as VAR from "@eslint-react/var";
import { AST_NODE_TYPES, ESLintUtils } from "@typescript-eslint/utils";
import { P, isMatching, match } from "ts-pattern";
import { AST_NODE_TYPES as AST_NODE_TYPES$1 } from "@typescript-eslint/types";

//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __export = (all) => {
	let target = {};
	for (var name$2 in all) __defProp(target, name$2, {
		get: all[name$2],
		enumerable: true
	});
	return target;
};

//#endregion
//#region src/configs/recommended.ts
var recommended_exports = __export({
	name: () => name$1,
	rules: () => rules,
	settings: () => settings
});
const name$1 = "react-web-api/recommended";
const rules = {
	"react-web-api/no-leaked-event-listener": "warn",
	"react-web-api/no-leaked-interval": "warn",
	"react-web-api/no-leaked-resize-observer": "warn",
	"react-web-api/no-leaked-timeout": "warn"
};
const settings = { "react-x": DEFAULT_ESLINT_REACT_SETTINGS };

//#endregion
//#region package.json
var name = "eslint-plugin-react-web-api";
var version = "1.53.1";

//#endregion
//#region src/utils/create-rule.ts
const createRule = ESLintUtils.RuleCreator(getDocsUrl("web-api"));

//#endregion
//#region src/utils/get-phase-kind-of-function.ts
function getPhaseKindOfFunction(node) {
	return match(node).when(ER.isFunctionOfUseEffectSetup, () => "setup").when(ER.isFunctionOfUseEffectCleanup, () => "cleanup").when(ER.isFunctionOfComponentDidMount, () => "mount").when(ER.isFunctionOfComponentWillUnmount, () => "unmount").otherwise(() => null);
}

//#endregion
//#region src/utils/is-conditional.ts
const isControlFlow = or(AST.isLoop, AST.isOneOf([AST_NODE_TYPES$1.IfStatement, AST_NODE_TYPES$1.SwitchStatement]));
const isConditional = or(isControlFlow, AST.isOneOf([AST_NODE_TYPES$1.LogicalExpression, AST_NODE_TYPES$1.ConditionalExpression]));

//#endregion
//#region src/rules/no-leaked-event-listener.ts
const RULE_NAME$3 = "no-leaked-event-listener";
const RULE_FEATURES$3 = [];
const defaultOptions = {
	capture: false,
	signal: unit
};
function getCallKind$3(node) {
	switch (true) {
		case node.callee.type === AST_NODE_TYPES.Identifier && isMatching(P.union("addEventListener", "removeEventListener", "abort"))(node.callee.name): return node.callee.name;
		case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && isMatching(P.union("addEventListener", "removeEventListener", "abort"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
function getFunctionKind$1(node) {
	return getPhaseKindOfFunction(node) ?? "other";
}
function getSignalValueExpression(node, initialScope) {
	if (node == null) return unit;
	switch (node.type) {
		case AST_NODE_TYPES.Identifier: return getSignalValueExpression(VAR.getVariableInitNode(VAR.findVariable(node, initialScope), 0), initialScope);
		case AST_NODE_TYPES.MemberExpression: return node;
		default: return unit;
	}
}
function getOptions(node, initialScope) {
	function findProp(properties, propName) {
		return VAR.findPropertyInProperties(propName, properties, initialScope);
	}
	function getPropValue(prop, filter = (a) => true) {
		if (prop?.type !== AST_NODE_TYPES.Property) return unit;
		const { value } = prop;
		let v = value;
		switch (value.type) {
			case AST_NODE_TYPES.Literal:
				v = value.value;
				break;
			default:
				v = VAR.toStaticValue({
					kind: "lazy",
					node: value,
					initialScope
				}).value;
				break;
		}
		return filter(v) ? v : unit;
	}
	function getOpts(node$1) {
		switch (node$1.type) {
			case AST_NODE_TYPES.Identifier: {
				const variable = VAR.findVariable(node$1, initialScope);
				const variableNode = VAR.getVariableInitNode(variable, 0);
				if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) return getOpts(variableNode);
				return defaultOptions;
			}
			case AST_NODE_TYPES.Literal: return {
				...defaultOptions,
				capture: Boolean(node$1.value)
			};
			case AST_NODE_TYPES.ObjectExpression: {
				const pCapture = findProp(node$1.properties, "capture");
				const vCapture = !!getPropValue(pCapture);
				const pSignal = findProp(node$1.properties, "signal");
				const vSignal = pSignal?.type === AST_NODE_TYPES.Property ? getSignalValueExpression(pSignal.value, initialScope) : unit;
				return {
					capture: vCapture,
					signal: vSignal
				};
			}
			default: return defaultOptions;
		}
	}
	return getOpts(node);
}
var no_leaked_event_listener_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `addEventListener` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$3
		},
		messages: {
			expectedRemoveEventListenerInCleanup: "An 'addEventListener' in '{{effectMethodKind}}' should have a corresponding 'removeEventListener' in its cleanup function.",
			expectedRemoveEventListenerInUnmount: "An 'addEventListener' in 'componentDidMount' should have a corresponding 'removeEventListener' in 'componentWillUnmount' method.",
			unexpectedInlineFunction: "A/an '{{eventMethodKind}}' should not have an inline listener function."
		},
		schema: []
	},
	name: RULE_NAME$3,
	create: create$3,
	defaultOptions: []
});
function create$3(context) {
	if (!context.sourceCode.text.includes("addEventListener")) return {};
	if (!/use\w*Effect|componentDidMount|componentWillUnmount/u.test(context.sourceCode.text)) return {};
	const fEntries = [];
	const aEntries = [];
	const rEntries = [];
	const abortedSignals = [];
	function isSameObject(a, b) {
		switch (true) {
			case a.type === AST_NODE_TYPES.MemberExpression && b.type === AST_NODE_TYPES.MemberExpression: return AST.isNodeEqual(a.object, b.object);
			default: return false;
		}
	}
	function isInverseEntry(aEntry, rEntry) {
		const { type: aType, callee: aCallee, capture: aCapture, listener: aListener, phase: aPhase } = aEntry;
		const { type: rType, callee: rCallee, capture: rCapture, listener: rListener, phase: rPhase } = rEntry;
		if (!ER.isInversePhase(aPhase, rPhase)) return false;
		return isSameObject(aCallee, rCallee) && AST.isNodeEqual(aListener, rListener) && VAR.isNodeValueEqual(aType, rType, [context.sourceCode.getScope(aType), context.sourceCode.getScope(rType)]) && aCapture === rCapture;
	}
	function checkInlineFunction(node, callKind, options) {
		const listener = node.arguments.at(1);
		if (!AST.isFunction(listener)) return;
		if (options.signal != null) return;
		context.report({
			messageId: "unexpectedInlineFunction",
			node: listener,
			data: { eventMethodKind: callKind }
		});
	}
	return {
		[":function"](node) {
			const kind = getFunctionKind$1(node);
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			const fKind = fEntries.findLast((x) => x.kind !== "other")?.kind;
			if (fKind == null) return;
			if (!ER.ComponentPhaseRelevance.has(fKind)) return;
			match(getCallKind$3(node)).with("addEventListener", (callKind) => {
				const [type, listener, options] = node.arguments;
				if (type == null || listener == null) return;
				const opts = options == null ? defaultOptions : getOptions(options, context.sourceCode.getScope(options));
				const { callee } = node;
				checkInlineFunction(node, callKind, opts);
				aEntries.push({
					...opts,
					kind: "addEventListener",
					type,
					node,
					callee,
					listener,
					phase: fKind
				});
			}).with("removeEventListener", (callKind) => {
				const [type, listener, options] = node.arguments;
				if (type == null || listener == null) return;
				const opts = options == null ? defaultOptions : getOptions(options, context.sourceCode.getScope(options));
				const { callee } = node;
				checkInlineFunction(node, callKind, opts);
				rEntries.push({
					...opts,
					kind: "removeEventListener",
					type,
					node,
					callee,
					listener,
					phase: fKind
				});
			}).with("abort", () => {
				abortedSignals.push(node.callee);
			}).otherwise(() => null);
		},
		["Program:exit"]() {
			for (const aEntry of aEntries) {
				const signal = aEntry.signal;
				if (signal != null && abortedSignals.some((a) => isSameObject(a, signal))) continue;
				if (rEntries.some((rEntry) => isInverseEntry(aEntry, rEntry))) continue;
				switch (aEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedRemoveEventListenerInCleanup",
							node: aEntry.node,
							data: { effectMethodKind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedRemoveEventListenerInUnmount",
							node: aEntry.node
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-interval.ts
const RULE_NAME$2 = "no-leaked-interval";
const RULE_FEATURES$2 = [];
function getCallKind$2(node) {
	switch (true) {
		case node.callee.type === AST_NODE_TYPES.Identifier && isMatching(P.union("setInterval", "clearInterval"))(node.callee.name): return node.callee.name;
		case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && isMatching(P.union("setInterval", "clearInterval"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
var no_leaked_interval_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `setInterval` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$2
		},
		messages: {
			expectedClearIntervalInCleanup: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the cleanup function.",
			expectedClearIntervalInUnmount: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the 'componentWillUnmount' method.",
			expectedIntervalId: "A 'setInterval' must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME$2,
	create: create$2,
	defaultOptions: []
});
function create$2(context) {
	if (!context.sourceCode.text.includes("setInterval")) return {};
	const fEntries = [];
	const sEntries = [];
	const cEntries = [];
	function isInverseEntry(a, b) {
		return ER.isInstanceIdEqual(context, a.timerId, b.timerId);
	}
	return {
		[":function"](node) {
			const kind = getPhaseKindOfFunction(node) ?? "other";
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			switch (getCallKind$2(node)) {
				case "setInterval": {
					const fEntry = fEntries.findLast((x) => x.kind !== "other");
					if (fEntry == null) break;
					if (!ER.ComponentPhaseRelevance.has(fEntry.kind)) break;
					const intervalIdNode = VAR.getVariableDeclaratorId(node);
					if (intervalIdNode == null) {
						context.report({
							messageId: "expectedIntervalId",
							node
						});
						break;
					}
					sEntries.push({
						kind: "interval",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: intervalIdNode
					});
					break;
				}
				case "clearInterval": {
					const fEntry = fEntries.findLast((x) => x.kind !== "other");
					if (fEntry == null) break;
					if (!ER.ComponentPhaseRelevance.has(fEntry.kind)) break;
					const [intervalIdNode] = node.arguments;
					if (intervalIdNode == null) break;
					cEntries.push({
						kind: "interval",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: intervalIdNode
					});
					break;
				}
			}
		},
		["Program:exit"]() {
			for (const sEntry of sEntries) {
				if (cEntries.some((cEntry) => isInverseEntry(sEntry, cEntry))) continue;
				switch (sEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedClearIntervalInCleanup",
							node: sEntry.node,
							data: { kind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedClearIntervalInUnmount",
							node: sEntry.node,
							data: { kind: "componentDidMount" }
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-resize-observer.ts
const RULE_NAME$1 = "no-leaked-resize-observer";
const RULE_FEATURES$1 = [];
function isNewResizeObserver(node) {
	return node?.type === AST_NODE_TYPES.NewExpression && node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === "ResizeObserver";
}
function isFromObserver(context, node) {
	switch (true) {
		case node.type === AST_NODE_TYPES.Identifier: {
			const initialScope = context.sourceCode.getScope(node);
			const object = VAR.getVariableInitNode(VAR.findVariable(node, initialScope), 0);
			return isNewResizeObserver(object);
		}
		case node.type === AST_NODE_TYPES.MemberExpression: return isFromObserver(context, node.object);
		default: return false;
	}
}
function getCallKind$1(context, node) {
	switch (true) {
		case node.callee.type === AST_NODE_TYPES.Identifier && isMatching(P.union("observe", "unobserve", "disconnect"))(node.callee.name) && isFromObserver(context, node.callee): return node.callee.name;
		case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && isMatching(P.union("observe", "unobserve", "disconnect"))(node.callee.property.name) && isFromObserver(context, node.callee): return node.callee.property.name;
		default: return "other";
	}
}
function getFunctionKind(node) {
	return getPhaseKindOfFunction(node) ?? "other";
}
var no_leaked_resize_observer_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `ResizeObserver` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$1
		},
		messages: {
			expectedDisconnectInControlFlow: "Dynamically added 'ResizeObserver.observe' should be cleared all at once using 'ResizeObserver.disconnect' in the cleanup function.",
			expectedDisconnectOrUnobserveInCleanup: "A 'ResizeObserver' instance created in 'useEffect' must be disconnected in the cleanup function.",
			unexpectedFloatingInstance: "A 'ResizeObserver' instance created in component or custom Hook must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME$1,
	create: create$1,
	defaultOptions: []
});
function create$1(context) {
	if (!context.sourceCode.text.includes("ResizeObserver")) return {};
	const fEntries = [];
	const observers = [];
	const oEntries = [];
	const uEntries = [];
	const dEntries = [];
	return {
		[":function"](node) {
			const kind = getFunctionKind(node);
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			if (node.callee.type !== AST_NODE_TYPES.MemberExpression) return;
			const fKind = fEntries.findLast((x) => x.kind !== "other")?.kind;
			if (fKind == null || !ER.ComponentPhaseRelevance.has(fKind)) return;
			const { object } = node.callee;
			match(getCallKind$1(context, node)).with("disconnect", () => {
				dEntries.push({
					kind: "disconnect",
					node,
					callee: node.callee,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).with("observe", () => {
				const [element] = node.arguments;
				if (element == null) return;
				oEntries.push({
					kind: "observe",
					node,
					callee: node.callee,
					element,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).with("unobserve", () => {
				const [element] = node.arguments;
				if (element == null) return;
				uEntries.push({
					kind: "unobserve",
					node,
					callee: node.callee,
					element,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).otherwise(() => null);
		},
		["NewExpression"](node) {
			const fEntry = fEntries.findLast((x) => x.kind !== "other");
			if (fEntry == null) return;
			if (!ER.ComponentPhaseRelevance.has(fEntry.kind)) return;
			if (!isNewResizeObserver(node)) return;
			const id = ER.getInstanceId(node);
			if (id == null) {
				context.report({
					messageId: "unexpectedFloatingInstance",
					node
				});
				return;
			}
			observers.push({
				id,
				node,
				phase: fEntry.kind,
				phaseNode: fEntry.node
			});
		},
		["Program:exit"]() {
			for (const { id, node, phaseNode } of observers) {
				if (dEntries.some((e) => ER.isInstanceIdEqual(context, e.observer, id))) continue;
				const oentries = oEntries.filter((e) => ER.isInstanceIdEqual(context, e.observer, id));
				const uentries = uEntries.filter((e) => ER.isInstanceIdEqual(context, e.observer, id));
				const isDynamic = (node$1) => node$1?.type === AST_NODE_TYPES.CallExpression || isConditional(node$1);
				const isPhaseNode = (node$1) => node$1 === phaseNode;
				if (oentries.some((e) => !isPhaseNode(AST.findParentNode(e.node, or(isDynamic, isPhaseNode))))) {
					context.report({
						messageId: "expectedDisconnectInControlFlow",
						node
					});
					continue;
				}
				for (const oEntry of oentries) {
					if (uentries.some((uEntry) => ER.isInstanceIdEqual(context, uEntry.element, oEntry.element))) continue;
					context.report({
						messageId: "expectedDisconnectOrUnobserveInCleanup",
						node: oEntry.node
					});
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-timeout.ts
const RULE_NAME = "no-leaked-timeout";
const RULE_FEATURES = [];
function getCallKind(node) {
	switch (true) {
		case node.callee.type === AST_NODE_TYPES.Identifier && isMatching(P.union("setTimeout", "clearTimeout"))(node.callee.name): return node.callee.name;
		case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && isMatching(P.union("setTimeout", "clearTimeout"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
var no_leaked_timeout_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `setTimeout` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES
		},
		messages: {
			expectedClearTimeoutInCleanup: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the cleanup function.",
			expectedClearTimeoutInUnmount: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the 'componentWillUnmount' method.",
			expectedTimeoutId: "A 'setTimeout' must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME,
	create,
	defaultOptions: []
});
function create(context) {
	if (!context.sourceCode.text.includes("setTimeout")) return {};
	const fEntries = [];
	const sEntries = [];
	const rEntries = [];
	function isInverseEntry(a, b) {
		return ER.isInstanceIdEqual(context, a.timerId, b.timerId);
	}
	return {
		[":function"](node) {
			const kind = getPhaseKindOfFunction(node) ?? "other";
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			const fEntry = fEntries.findLast((f) => f.kind !== "other");
			if (!ER.ComponentPhaseRelevance.has(fEntry?.kind)) return;
			switch (getCallKind(node)) {
				case "setTimeout": {
					const timeoutIdNode = VAR.getVariableDeclaratorId(node);
					if (timeoutIdNode == null) {
						context.report({
							messageId: "expectedTimeoutId",
							node
						});
						break;
					}
					sEntries.push({
						kind: "timeout",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: timeoutIdNode
					});
					break;
				}
				case "clearTimeout": {
					const [timeoutIdNode] = node.arguments;
					if (timeoutIdNode == null) break;
					rEntries.push({
						kind: "timeout",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: timeoutIdNode
					});
					break;
				}
			}
		},
		["Program:exit"]() {
			for (const sEntry of sEntries) {
				if (rEntries.some((rEntry) => isInverseEntry(sEntry, rEntry))) continue;
				switch (sEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedClearTimeoutInCleanup",
							node: sEntry.node,
							data: { kind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedClearTimeoutInUnmount",
							node: sEntry.node,
							data: { kind: "componentDidMount" }
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/plugin.ts
const plugin = {
	meta: {
		name,
		version
	},
	rules: {
		"no-leaked-event-listener": no_leaked_event_listener_default,
		"no-leaked-interval": no_leaked_interval_default,
		"no-leaked-resize-observer": no_leaked_resize_observer_default,
		"no-leaked-timeout": no_leaked_timeout_default
	}
};

//#endregion
//#region src/index.ts
const { toFlatConfig, toLegacyConfig } = getConfigAdapters("react-web-api", plugin);
var src_default = {
	...plugin,
	configs: {
		["recommended"]: toFlatConfig(recommended_exports),
		["recommended-legacy"]: toLegacyConfig(recommended_exports)
	}
};

//#endregion
export { src_default as default };