//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (all) => {
	let target = {};
	for (var name$2 in all) __defProp(target, name$2, {
		get: all[name$2],
		enumerable: true
	});
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let __eslint_react_shared = require("@eslint-react/shared");
__eslint_react_shared = __toESM(__eslint_react_shared);
let __eslint_react_ast = require("@eslint-react/ast");
__eslint_react_ast = __toESM(__eslint_react_ast);
let __eslint_react_core = require("@eslint-react/core");
__eslint_react_core = __toESM(__eslint_react_core);
let __eslint_react_eff = require("@eslint-react/eff");
__eslint_react_eff = __toESM(__eslint_react_eff);
let __eslint_react_var = require("@eslint-react/var");
__eslint_react_var = __toESM(__eslint_react_var);
let __typescript_eslint_utils = require("@typescript-eslint/utils");
__typescript_eslint_utils = __toESM(__typescript_eslint_utils);
let ts_pattern = require("ts-pattern");
ts_pattern = __toESM(ts_pattern);
let __typescript_eslint_types = require("@typescript-eslint/types");
__typescript_eslint_types = __toESM(__typescript_eslint_types);

//#region src/configs/recommended.ts
var recommended_exports = __export({
	name: () => name$1,
	rules: () => rules,
	settings: () => settings
});
const name$1 = "react-web-api/recommended";
const rules = {
	"react-web-api/no-leaked-event-listener": "warn",
	"react-web-api/no-leaked-interval": "warn",
	"react-web-api/no-leaked-resize-observer": "warn",
	"react-web-api/no-leaked-timeout": "warn"
};
const settings = { "react-x": __eslint_react_shared.DEFAULT_ESLINT_REACT_SETTINGS };

//#endregion
//#region package.json
var name = "eslint-plugin-react-web-api";
var version = "1.53.1";

//#endregion
//#region src/utils/create-rule.ts
const createRule = __typescript_eslint_utils.ESLintUtils.RuleCreator((0, __eslint_react_shared.getDocsUrl)("web-api"));

//#endregion
//#region src/utils/get-phase-kind-of-function.ts
function getPhaseKindOfFunction(node) {
	return (0, ts_pattern.match)(node).when(__eslint_react_core.isFunctionOfUseEffectSetup, () => "setup").when(__eslint_react_core.isFunctionOfUseEffectCleanup, () => "cleanup").when(__eslint_react_core.isFunctionOfComponentDidMount, () => "mount").when(__eslint_react_core.isFunctionOfComponentWillUnmount, () => "unmount").otherwise(() => null);
}

//#endregion
//#region src/utils/is-conditional.ts
const isControlFlow = (0, __eslint_react_eff.or)(__eslint_react_ast.isLoop, __eslint_react_ast.isOneOf([__typescript_eslint_types.AST_NODE_TYPES.IfStatement, __typescript_eslint_types.AST_NODE_TYPES.SwitchStatement]));
const isConditional = (0, __eslint_react_eff.or)(isControlFlow, __eslint_react_ast.isOneOf([__typescript_eslint_types.AST_NODE_TYPES.LogicalExpression, __typescript_eslint_types.AST_NODE_TYPES.ConditionalExpression]));

//#endregion
//#region src/rules/no-leaked-event-listener.ts
const RULE_NAME$3 = "no-leaked-event-listener";
const RULE_FEATURES$3 = [];
const defaultOptions = {
	capture: false,
	signal: __eslint_react_eff.unit
};
function getCallKind$3(node) {
	switch (true) {
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("addEventListener", "removeEventListener", "abort"))(node.callee.name): return node.callee.name;
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("addEventListener", "removeEventListener", "abort"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
function getFunctionKind$1(node) {
	return getPhaseKindOfFunction(node) ?? "other";
}
function getSignalValueExpression(node, initialScope) {
	if (node == null) return __eslint_react_eff.unit;
	switch (node.type) {
		case __typescript_eslint_utils.AST_NODE_TYPES.Identifier: return getSignalValueExpression(__eslint_react_var.getVariableInitNode(__eslint_react_var.findVariable(node, initialScope), 0), initialScope);
		case __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression: return node;
		default: return __eslint_react_eff.unit;
	}
}
function getOptions(node, initialScope) {
	function findProp(properties, propName) {
		return __eslint_react_var.findPropertyInProperties(propName, properties, initialScope);
	}
	function getPropValue(prop, filter = (a) => true) {
		if (prop?.type !== __typescript_eslint_utils.AST_NODE_TYPES.Property) return __eslint_react_eff.unit;
		const { value } = prop;
		let v = value;
		switch (value.type) {
			case __typescript_eslint_utils.AST_NODE_TYPES.Literal:
				v = value.value;
				break;
			default:
				v = __eslint_react_var.toStaticValue({
					kind: "lazy",
					node: value,
					initialScope
				}).value;
				break;
		}
		return filter(v) ? v : __eslint_react_eff.unit;
	}
	function getOpts(node$1) {
		switch (node$1.type) {
			case __typescript_eslint_utils.AST_NODE_TYPES.Identifier: {
				const variable = __eslint_react_var.findVariable(node$1, initialScope);
				const variableNode = __eslint_react_var.getVariableInitNode(variable, 0);
				if (variableNode?.type === __typescript_eslint_utils.AST_NODE_TYPES.ObjectExpression) return getOpts(variableNode);
				return defaultOptions;
			}
			case __typescript_eslint_utils.AST_NODE_TYPES.Literal: return {
				...defaultOptions,
				capture: Boolean(node$1.value)
			};
			case __typescript_eslint_utils.AST_NODE_TYPES.ObjectExpression: {
				const pCapture = findProp(node$1.properties, "capture");
				const vCapture = !!getPropValue(pCapture);
				const pSignal = findProp(node$1.properties, "signal");
				const vSignal = pSignal?.type === __typescript_eslint_utils.AST_NODE_TYPES.Property ? getSignalValueExpression(pSignal.value, initialScope) : __eslint_react_eff.unit;
				return {
					capture: vCapture,
					signal: vSignal
				};
			}
			default: return defaultOptions;
		}
	}
	return getOpts(node);
}
var no_leaked_event_listener_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `addEventListener` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$3
		},
		messages: {
			expectedRemoveEventListenerInCleanup: "An 'addEventListener' in '{{effectMethodKind}}' should have a corresponding 'removeEventListener' in its cleanup function.",
			expectedRemoveEventListenerInUnmount: "An 'addEventListener' in 'componentDidMount' should have a corresponding 'removeEventListener' in 'componentWillUnmount' method.",
			unexpectedInlineFunction: "A/an '{{eventMethodKind}}' should not have an inline listener function."
		},
		schema: []
	},
	name: RULE_NAME$3,
	create: create$3,
	defaultOptions: []
});
function create$3(context) {
	if (!context.sourceCode.text.includes("addEventListener")) return {};
	if (!/use\w*Effect|componentDidMount|componentWillUnmount/u.test(context.sourceCode.text)) return {};
	const fEntries = [];
	const aEntries = [];
	const rEntries = [];
	const abortedSignals = [];
	function isSameObject(a, b) {
		switch (true) {
			case a.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression && b.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression: return __eslint_react_ast.isNodeEqual(a.object, b.object);
			default: return false;
		}
	}
	function isInverseEntry(aEntry, rEntry) {
		const { type: aType, callee: aCallee, capture: aCapture, listener: aListener, phase: aPhase } = aEntry;
		const { type: rType, callee: rCallee, capture: rCapture, listener: rListener, phase: rPhase } = rEntry;
		if (!__eslint_react_core.isInversePhase(aPhase, rPhase)) return false;
		return isSameObject(aCallee, rCallee) && __eslint_react_ast.isNodeEqual(aListener, rListener) && __eslint_react_var.isNodeValueEqual(aType, rType, [context.sourceCode.getScope(aType), context.sourceCode.getScope(rType)]) && aCapture === rCapture;
	}
	function checkInlineFunction(node, callKind, options) {
		const listener = node.arguments.at(1);
		if (!__eslint_react_ast.isFunction(listener)) return;
		if (options.signal != null) return;
		context.report({
			messageId: "unexpectedInlineFunction",
			node: listener,
			data: { eventMethodKind: callKind }
		});
	}
	return {
		[":function"](node) {
			const kind = getFunctionKind$1(node);
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			const fKind = fEntries.findLast((x) => x.kind !== "other")?.kind;
			if (fKind == null) return;
			if (!__eslint_react_core.ComponentPhaseRelevance.has(fKind)) return;
			(0, ts_pattern.match)(getCallKind$3(node)).with("addEventListener", (callKind) => {
				const [type, listener, options] = node.arguments;
				if (type == null || listener == null) return;
				const opts = options == null ? defaultOptions : getOptions(options, context.sourceCode.getScope(options));
				const { callee } = node;
				checkInlineFunction(node, callKind, opts);
				aEntries.push({
					...opts,
					kind: "addEventListener",
					type,
					node,
					callee,
					listener,
					phase: fKind
				});
			}).with("removeEventListener", (callKind) => {
				const [type, listener, options] = node.arguments;
				if (type == null || listener == null) return;
				const opts = options == null ? defaultOptions : getOptions(options, context.sourceCode.getScope(options));
				const { callee } = node;
				checkInlineFunction(node, callKind, opts);
				rEntries.push({
					...opts,
					kind: "removeEventListener",
					type,
					node,
					callee,
					listener,
					phase: fKind
				});
			}).with("abort", () => {
				abortedSignals.push(node.callee);
			}).otherwise(() => null);
		},
		["Program:exit"]() {
			for (const aEntry of aEntries) {
				const signal = aEntry.signal;
				if (signal != null && abortedSignals.some((a) => isSameObject(a, signal))) continue;
				if (rEntries.some((rEntry) => isInverseEntry(aEntry, rEntry))) continue;
				switch (aEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedRemoveEventListenerInCleanup",
							node: aEntry.node,
							data: { effectMethodKind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedRemoveEventListenerInUnmount",
							node: aEntry.node
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-interval.ts
const RULE_NAME$2 = "no-leaked-interval";
const RULE_FEATURES$2 = [];
function getCallKind$2(node) {
	switch (true) {
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("setInterval", "clearInterval"))(node.callee.name): return node.callee.name;
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("setInterval", "clearInterval"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
var no_leaked_interval_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `setInterval` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$2
		},
		messages: {
			expectedClearIntervalInCleanup: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the cleanup function.",
			expectedClearIntervalInUnmount: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the 'componentWillUnmount' method.",
			expectedIntervalId: "A 'setInterval' must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME$2,
	create: create$2,
	defaultOptions: []
});
function create$2(context) {
	if (!context.sourceCode.text.includes("setInterval")) return {};
	const fEntries = [];
	const sEntries = [];
	const cEntries = [];
	function isInverseEntry(a, b) {
		return __eslint_react_core.isInstanceIdEqual(context, a.timerId, b.timerId);
	}
	return {
		[":function"](node) {
			const kind = getPhaseKindOfFunction(node) ?? "other";
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			switch (getCallKind$2(node)) {
				case "setInterval": {
					const fEntry = fEntries.findLast((x) => x.kind !== "other");
					if (fEntry == null) break;
					if (!__eslint_react_core.ComponentPhaseRelevance.has(fEntry.kind)) break;
					const intervalIdNode = __eslint_react_var.getVariableDeclaratorId(node);
					if (intervalIdNode == null) {
						context.report({
							messageId: "expectedIntervalId",
							node
						});
						break;
					}
					sEntries.push({
						kind: "interval",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: intervalIdNode
					});
					break;
				}
				case "clearInterval": {
					const fEntry = fEntries.findLast((x) => x.kind !== "other");
					if (fEntry == null) break;
					if (!__eslint_react_core.ComponentPhaseRelevance.has(fEntry.kind)) break;
					const [intervalIdNode] = node.arguments;
					if (intervalIdNode == null) break;
					cEntries.push({
						kind: "interval",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: intervalIdNode
					});
					break;
				}
			}
		},
		["Program:exit"]() {
			for (const sEntry of sEntries) {
				if (cEntries.some((cEntry) => isInverseEntry(sEntry, cEntry))) continue;
				switch (sEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedClearIntervalInCleanup",
							node: sEntry.node,
							data: { kind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedClearIntervalInUnmount",
							node: sEntry.node,
							data: { kind: "componentDidMount" }
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-resize-observer.ts
const RULE_NAME$1 = "no-leaked-resize-observer";
const RULE_FEATURES$1 = [];
function isNewResizeObserver(node) {
	return node?.type === __typescript_eslint_utils.AST_NODE_TYPES.NewExpression && node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && node.callee.name === "ResizeObserver";
}
function isFromObserver(context, node) {
	switch (true) {
		case node.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier: {
			const initialScope = context.sourceCode.getScope(node);
			const object = __eslint_react_var.getVariableInitNode(__eslint_react_var.findVariable(node, initialScope), 0);
			return isNewResizeObserver(object);
		}
		case node.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression: return isFromObserver(context, node.object);
		default: return false;
	}
}
function getCallKind$1(context, node) {
	switch (true) {
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("observe", "unobserve", "disconnect"))(node.callee.name) && isFromObserver(context, node.callee): return node.callee.name;
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("observe", "unobserve", "disconnect"))(node.callee.property.name) && isFromObserver(context, node.callee): return node.callee.property.name;
		default: return "other";
	}
}
function getFunctionKind(node) {
	return getPhaseKindOfFunction(node) ?? "other";
}
var no_leaked_resize_observer_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `ResizeObserver` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES$1
		},
		messages: {
			expectedDisconnectInControlFlow: "Dynamically added 'ResizeObserver.observe' should be cleared all at once using 'ResizeObserver.disconnect' in the cleanup function.",
			expectedDisconnectOrUnobserveInCleanup: "A 'ResizeObserver' instance created in 'useEffect' must be disconnected in the cleanup function.",
			unexpectedFloatingInstance: "A 'ResizeObserver' instance created in component or custom Hook must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME$1,
	create: create$1,
	defaultOptions: []
});
function create$1(context) {
	if (!context.sourceCode.text.includes("ResizeObserver")) return {};
	const fEntries = [];
	const observers = [];
	const oEntries = [];
	const uEntries = [];
	const dEntries = [];
	return {
		[":function"](node) {
			const kind = getFunctionKind(node);
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			if (node.callee.type !== __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression) return;
			const fKind = fEntries.findLast((x) => x.kind !== "other")?.kind;
			if (fKind == null || !__eslint_react_core.ComponentPhaseRelevance.has(fKind)) return;
			const { object } = node.callee;
			(0, ts_pattern.match)(getCallKind$1(context, node)).with("disconnect", () => {
				dEntries.push({
					kind: "disconnect",
					node,
					callee: node.callee,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).with("observe", () => {
				const [element] = node.arguments;
				if (element == null) return;
				oEntries.push({
					kind: "observe",
					node,
					callee: node.callee,
					element,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).with("unobserve", () => {
				const [element] = node.arguments;
				if (element == null) return;
				uEntries.push({
					kind: "unobserve",
					node,
					callee: node.callee,
					element,
					observer: object,
					observerKind: "ResizeObserver",
					phase: fKind
				});
			}).otherwise(() => null);
		},
		["NewExpression"](node) {
			const fEntry = fEntries.findLast((x) => x.kind !== "other");
			if (fEntry == null) return;
			if (!__eslint_react_core.ComponentPhaseRelevance.has(fEntry.kind)) return;
			if (!isNewResizeObserver(node)) return;
			const id = __eslint_react_core.getInstanceId(node);
			if (id == null) {
				context.report({
					messageId: "unexpectedFloatingInstance",
					node
				});
				return;
			}
			observers.push({
				id,
				node,
				phase: fEntry.kind,
				phaseNode: fEntry.node
			});
		},
		["Program:exit"]() {
			for (const { id, node, phaseNode } of observers) {
				if (dEntries.some((e) => __eslint_react_core.isInstanceIdEqual(context, e.observer, id))) continue;
				const oentries = oEntries.filter((e) => __eslint_react_core.isInstanceIdEqual(context, e.observer, id));
				const uentries = uEntries.filter((e) => __eslint_react_core.isInstanceIdEqual(context, e.observer, id));
				const isDynamic = (node$1) => node$1?.type === __typescript_eslint_utils.AST_NODE_TYPES.CallExpression || isConditional(node$1);
				const isPhaseNode = (node$1) => node$1 === phaseNode;
				if (oentries.some((e) => !isPhaseNode(__eslint_react_ast.findParentNode(e.node, (0, __eslint_react_eff.or)(isDynamic, isPhaseNode))))) {
					context.report({
						messageId: "expectedDisconnectInControlFlow",
						node
					});
					continue;
				}
				for (const oEntry of oentries) {
					if (uentries.some((uEntry) => __eslint_react_core.isInstanceIdEqual(context, uEntry.element, oEntry.element))) continue;
					context.report({
						messageId: "expectedDisconnectOrUnobserveInCleanup",
						node: oEntry.node
					});
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-leaked-timeout.ts
const RULE_NAME = "no-leaked-timeout";
const RULE_FEATURES = [];
function getCallKind(node) {
	switch (true) {
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("setTimeout", "clearTimeout"))(node.callee.name): return node.callee.name;
		case node.callee.type === __typescript_eslint_utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_utils.AST_NODE_TYPES.Identifier && (0, ts_pattern.isMatching)(ts_pattern.P.union("setTimeout", "clearTimeout"))(node.callee.property.name): return node.callee.property.name;
		default: return "other";
	}
}
var no_leaked_timeout_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents leaked `setTimeout` in a component or custom Hook.",
			[Symbol.for("rule_features")]: RULE_FEATURES
		},
		messages: {
			expectedClearTimeoutInCleanup: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the cleanup function.",
			expectedClearTimeoutInUnmount: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the 'componentWillUnmount' method.",
			expectedTimeoutId: "A 'setTimeout' must be assigned to a variable for proper cleanup."
		},
		schema: []
	},
	name: RULE_NAME,
	create,
	defaultOptions: []
});
function create(context) {
	if (!context.sourceCode.text.includes("setTimeout")) return {};
	const fEntries = [];
	const sEntries = [];
	const rEntries = [];
	function isInverseEntry(a, b) {
		return __eslint_react_core.isInstanceIdEqual(context, a.timerId, b.timerId);
	}
	return {
		[":function"](node) {
			const kind = getPhaseKindOfFunction(node) ?? "other";
			fEntries.push({
				kind,
				node
			});
		},
		[":function:exit"]() {
			fEntries.pop();
		},
		["CallExpression"](node) {
			const fEntry = fEntries.findLast((f) => f.kind !== "other");
			if (!__eslint_react_core.ComponentPhaseRelevance.has(fEntry?.kind)) return;
			switch (getCallKind(node)) {
				case "setTimeout": {
					const timeoutIdNode = __eslint_react_var.getVariableDeclaratorId(node);
					if (timeoutIdNode == null) {
						context.report({
							messageId: "expectedTimeoutId",
							node
						});
						break;
					}
					sEntries.push({
						kind: "timeout",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: timeoutIdNode
					});
					break;
				}
				case "clearTimeout": {
					const [timeoutIdNode] = node.arguments;
					if (timeoutIdNode == null) break;
					rEntries.push({
						kind: "timeout",
						node,
						callee: node.callee,
						phase: fEntry.kind,
						timerId: timeoutIdNode
					});
					break;
				}
			}
		},
		["Program:exit"]() {
			for (const sEntry of sEntries) {
				if (rEntries.some((rEntry) => isInverseEntry(sEntry, rEntry))) continue;
				switch (sEntry.phase) {
					case "setup":
					case "cleanup":
						context.report({
							messageId: "expectedClearTimeoutInCleanup",
							node: sEntry.node,
							data: { kind: "useEffect" }
						});
						continue;
					case "mount":
					case "unmount":
						context.report({
							messageId: "expectedClearTimeoutInUnmount",
							node: sEntry.node,
							data: { kind: "componentDidMount" }
						});
						continue;
				}
			}
		}
	};
}

//#endregion
//#region src/plugin.ts
const plugin = {
	meta: {
		name,
		version
	},
	rules: {
		"no-leaked-event-listener": no_leaked_event_listener_default,
		"no-leaked-interval": no_leaked_interval_default,
		"no-leaked-resize-observer": no_leaked_resize_observer_default,
		"no-leaked-timeout": no_leaked_timeout_default
	}
};

//#endregion
//#region src/index.ts
const { toFlatConfig, toLegacyConfig } = (0, __eslint_react_shared.getConfigAdapters)("react-web-api", plugin);
var src_default = {
	...plugin,
	configs: {
		["recommended"]: toFlatConfig(recommended_exports),
		["recommended-legacy"]: toLegacyConfig(recommended_exports)
	}
};

//#endregion
module.exports = src_default;